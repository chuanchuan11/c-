>> 命令模式

#### 应用场景

```
    定义: 将一个请求（行为）封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理
          
    应用场景: 
        a) 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互
        
        b) 系统需要在不同的时间指定请求、将请求排队和执行请求
        
        c) 系统需要支持命令的撤销 (Undo)操作和恢复 (Redo)操作
        
```

#### 优缺点

```
    优点: 
        a) 它能较容易的设计一个命令队列, 允许接收请求的一方决定是否要否决请求, 可以容易的实现对请求的撤销和重做
        
        b) 由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易

    缺点: 
        命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用
```

#### 模式设计

```
1) 触发者（Invoker):
    类负责必须包含一个成员变量来存储对于命令对象的引用。触发命令，而不向接收者直接发送请求。注意，并不负责创建命令对象：它通常会通过构造函数从客户端处获得预先生成的命令

2) 命令（Command）接口
    通常仅声明一个执行命令的方法

3) 具体命令（Concrete Commands）
    会实现各种类型的请求。具体命令自身并不完成工作，而是会将调用委派给一个业务逻辑对象。接收对象执行方法所需的参数可以声明为具体命令的成员变量。你可以将命令对象设为不可变，仅允许通过构造函数对这些成员变量进行初始化

4) 接收者（Receiver）类
    包含部分业务逻辑。几乎任何对象都可以作为接收者。绝大部分命令只处理如何将请求传递到接收者的细节，接收者自己会完成实际的工作

5) 客户端（Client）
    创建并配置具体命令对象。客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。此后，生成的命令就可以与一个或多个触发者相关联了

```

![image](https://github.com/chuanchuan11/cplus/assets/42632290/27801633-bb93-4453-a88b-cdd75850597f)

#### 示例

```
代码: 附件
```
