>> 享元模式

#### 应用场景

```
    定义: 享元模式的核心思想是在使用大量细粒度的对象的时候运用共享技术共享其中相同的部分。从而避免造成在分配资源的造成巨额的额外开销

    举个例子：比如说围棋游戏，那么多黑白棋子，不是每放一颗棋子都new一个棋子，不然的话会巨额的开销. 对于白子来说，其属性包括形状、颜色和位置等。其中形状和颜色，对于一方而言，每次摆放时都是相同的属性，不同的只有位置。

    享元模式关键之处在于共享的是哪些内在的状态，外部状态是变化，不可共享。上面提到的围棋，棋子的材质和颜色是可以共享的，他们是固定不变的，而其在棋盘上坐标位置是不可以共享，因为每一颗棋子的位置是不一样的

    应用场景:
        以共享的方式, 高效的支持大量的细粒度对象
```

#### 优缺点

```
优点：
    a) 享元模式可以减少内存占用，提高程序的性能。它通过共享对象来减少对象的数量，从而减少内存占用
    
    b) 它可以提高程序的执行速度。由于对象数量减少，程序在运行时需要处理的对象也减少了，因此程序的执行速度会更快

缺点：
    a) 享元模式会增加程序的复杂性。需要将对象的状态分为内部状态和外部状态，并在实现享元对象时考虑如何共享内部状态
    
    b) 它可能会增加程序的维护成本。由于享元模式将对象的创建和使用分离，需要在客户端代码中管理外部状态，并在使用享元对象时将外部状态传递给它。这可能会增加程序的维护成本
```

#### 模式设计

```
a) Flyweight: 抽象享元角色
    所有具体享元类的父类, 规定一些需要实现的公共接口

b) ConcreteFlyweight: 具体享元角色
    抽象享元角色的具体实现类, 并实现了抽象享元规定的方法

c) FlyweightFactory: 享元工厂角色
    负责创建和管理享元角色

```

![image](https://github.com/chuanchuan11/cplus/assets/42632290/2eee4c94-af18-46a2-a8de-8d5b7274da8f)

#### 示例

```
示例: 
     在围棋中，棋子就是大量细粒度的对象。其属性有内在的，比如颜色、形状等，也有外在的，比如在棋盘上的位置。内在的属性是可以共享的，区分在于外在属性。因此，可以这样设计，只需定义两个棋子的对象，一颗黑棋和一颗白棋，这两个对象含棋子的内在属性；棋子的外在属性，即在棋盘上的位置可以提取出来，存放在单独的容器中

代码: 
    附件

```

