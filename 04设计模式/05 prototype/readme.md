>> 原型模式

#### 应用场景

```
    一个基类, 有很多派生类, 在实际开发中, 经常会使用一个基类指针, 将其指向不同派生类的实例, 以实现多态.
    
    之后经过很长的业务操作之后, 需要一个该派生类对象的拷贝, 可能出现忘记了或难以确定该基类指针所指向的对象具体类型, 所以原型模式登场了。

```

#### 优缺点

```
    (1) 无需确定基类指针所指向的对象类型，即可获得相同类型的实例，提高了创建效率
    
    (2) 隔离类对象的使用者和具体类型之间的耦合关系, 但同样要求这些类拥有稳定的接口
    
    (3) 每个派生类都需要实现Clone()方法，增加了代码量. 需要注意**深拷贝和浅拷贝问题**

```

#### 模式设计

```
    (1) prototype
      
          在基类中添加一个用于派生类拷贝的纯虚函数Clone()，每个想要被实例化的派生类都需要去实现该方法
    
    (2) concreteProtope
    
          具体派生类, 需要实现clone函数, 调用自身类的拷贝构造函数, 并将自身（*this）传入拷贝构造函数
    
```

![image](https://user-images.githubusercontent.com/42632290/233825616-1b1562ba-8c8b-4b36-a498-fa41671b1390.png)

#### 示例

```
    举例：
    
    有一个果汁的抽象类和各品种果汁的实现类，我们使用了一个果汁类的基类指针指向了一个派生的葡萄汁实例。在过了很久很久之后，需要创建一份该指针所指向果汁的拷贝，
    
    但此时单纯通过这个基类指针是没有办法确定该果汁的品种的，所以我们需要每个品种的果汁类都能提供一个方法，用以获得该品种果汁的拷贝
    
    代码：
         附件
```

