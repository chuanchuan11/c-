>> 策略模式

#### 应用场景

```
    定义: 
        定义一系列的算法,把它们一个个封装起来, 为所有算法定义一个抽象的算法接口，并通过继承该抽象算法接口对所有的算法加以封装和实现，具体算法选择交由客户端决定, Strategy模式主要用来平滑地处理算法的切换
    
    应用场景: 
        对于同一流程中不同的需求，对数据的处理算法可能会变更，所以将处理数据的算法单独抽离出去，形成一系列算法类，可以相互替换  
```

#### 优缺点

```
    优点: 
        a) 简化单元测试, 因为每个算法都有自己的类, 可以通过自己的接口单独测试
        
        b) 避免程序中使用多重条件转移语句，是系统更灵活，并易于扩展
        
    缺点:
        a) 每个策略类都会产生一个新类, 所以会增加系统维护的类的数量
```

#### 模式设计

```
1) Strategy:
    策略接口抽象
    
2) ConcreteStrategy:
    各种策略的具体实现
    
3) Context:
    策略的外部封装类, 或者说策略的容器类. 根据不同策略执行不同的行为,策略由外部环境决定
```

![image](https://github.com/chuanchuan11/cplus/assets/42632290/c5c12d85-7cdd-4c6f-8aec-48f6a5c8ba0d)

#### 示例

```
示例1:
    由客户端自己指定选择的策略
代码:
    附件:strategy1.cpp
    
示例2:
    在实际操作的过程中, 在main函数中，也就是在客户端使用策略模式时, 会创建非常多的Strategy，而这样就莫名的增加了客户端的压力，让客户端的复杂度陡然增加了. 那么我们就可以借鉴简单工厂模式
代码:
    附件:strategy2.cpp
```
