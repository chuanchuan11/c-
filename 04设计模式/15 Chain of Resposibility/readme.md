>> 责任链模式

#### 应用场景

```
    背景: 
        当一个请求需经过多个节点的处理，如不考虑任何模式，每个对象要根据是否符合条件来决定是不是自己处理，这样就要使用if-else去处理。确定了类似A->B->C->D的处理流程后就不能再修改（除非修改源代码），导致客户端无法定制处理流程。无法在运行时动态的增加、修改或者删除处理流程中的处理节点，灵活性缺失。

    定义:
        使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象能够处理它为止
    
    纯的责任链模式:
        一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况
    不纯的责任链模式:
        在一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。

    注：在实际软件系统中，很少能找到纯的责任链模式，大多数情况是不纯的责任链模式

    应用场景:
        a) 一个事件需要经过多个对象处理是一个挺常见的场景，譬如采购审批流程，请假流程，软件开发中的异常处理流程，web请求处理流程等各种各样的流程，可以考虑使用责任链模式来实现。
        
        b) 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序
```

#### 优缺点

```
    优点:
        a) 对象仅需知道该请求会被处理即可，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度

        b) 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接

        c) 在给对象分派职责时，职责链可以给我们更多的灵活性，可以在运行时对该链进行动态的增删改，改变处理一个请求的职责

        d) 增一个新的具体请求处理者时无须修改原有代码，只需要在客户端重新建链即可，符合 “开闭原则”

    缺点:
        a) 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，且不方便调试。
        
        b) 可能因为职责链创建不当，造成循环调用，导致系统陷入死循环。
```

#### 模式设计

```
Client（客户端）：
    向处理者提交请求对象。

Handler（抽象处理者）：
    定义了一个处理请求的接口，设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。持有下一个抽象处理者的引用，通过该引用，处理者可以连成一条链。

ConcreteHandler（具体处理者）：
    抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发
```


#### 示例

```

```
