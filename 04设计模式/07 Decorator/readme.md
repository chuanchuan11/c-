>> 装饰模式

#### 应用场景

```
    对类进行功能增加方法:
      
      1) 直接修改原类
      
      2) 继承后, 在扩展
      
      3) 装饰模式

    在某些情况下我们可能会 "过度地使用继承来扩展对象的功能", 由于继承为类型引入的静态特质, 使得这种扩展方式缺乏灵活性; 并且随着子类的增多(扩展功能的增多), 各种子类的组合(扩展功能的组合)会导致更多子类的膨胀
    
    动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活

```

#### 优缺点

```

    1) 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能

    2) 多层装饰比较复杂. 减少了类的数量, 但是在装饰的过程中每一步都会产生一个对象, 对于debug来说会困难很多, 因为中间每一步产生的对象都很像
    
```

#### 模式设计

```

(1) Component是定义一个对象接口, 可以给这些对象动态添加职责

(2) ConcreteComponent是定义了一个具体对象, 也可以给对象添加一些职责

(3) Decorator 装饰器抽象类, 继承Component, 从外类来扩展Component 的功能, 但是对于Component来讲, 无需知道Decorator 的存在

(4) ConcreteDecorator具体修饰对象, 起到给 Component 添加职责的功能

```

![image](https://user-images.githubusercontent.com/42632290/236661797-f40a682e-ca6b-4b45-bb77-3aedd7be47eb.png)

#### 示例

应用1: 给形状添加新的特征 不同形状加红

    创建形状, 拥有方形和圆形, 又想要给方形和圆形染色为红色, 按照以往的逻辑, 需要给方形和圆形在增加对应的子类, 在子类里面增加红色.
    
    但是在这里, 我们尝试换一种思路, 增加一个形状子类命名为抽象装饰器类, 里面创建对应的形状对象, 这样当传入的不管是圆还是方形, 都在这个类里面增加染为红色的方法, 这样就实现了装饰器的功能

![image](https://user-images.githubusercontent.com/42632290/236661699-45ff5433-86e7-4269-bad6-66f094a096f0.png)

```
参考: decorator.cpp
```

