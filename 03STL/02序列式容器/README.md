> ## 序列式容器

##### 0. 概述

  所谓序列容器，即以线性排列（类似普通数组的存储方式）来存储某一指定类型的数据，该类容器并不会自动对存储的元素按照值的大小进行排序

```
array<T,N>（数组容器）：容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；

vector<T>（向量容器）：长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；

deque<T>（双端队列容器）：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；

list<T>（链表容器）：是一个长度可变的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list<T> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。

forward_list<T>（正向链表容器）：和 list 容器类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。

注意：stack<T> 和 queue<T> 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器，后续介绍

```

![image](https://user-images.githubusercontent.com/42632290/171986585-439f233f-0f3b-47c3-88a6-9a1933954db8.png)

##### 1. array容器

(0) 概述
    
  array 容器是 C++ 11 标准中新增的序列容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全（原因后续会讲），且效率并没有因此变差。

  array 容器的大小是固定的，无法动态的扩展或收缩，这也就意味着，在使用过程中无法通过增加或移除元素而改变其大小，**只允许访问或者替换存储的元素**。

```
1. 头文件  <array> 

    #include <array>
    using namespace std;

2. array 容器以类模板的形式定义

   namespace std{
        template <typename T, size_t N>
        class array;
   }

   注意：array<T,N> 类模板中，T 用于指明容器中的存储的具体数据类型，N 用于指明容器的大小. 这里的 N 必须是常量，不能用变量表示

```

(1) 创建

```
a) 直接创建
    std::array<double, 10> values;    //各个元素的值是不确定的，array 容器不会做默认初始化操作
    
b) 创建并使用默认初始化为0    
    std::array<double, 10> values {}; //所有的元素被初始化为 0.0
    
c) 创建并自定义初始化值  
    std::array<double, 10> values {0.5,1.0,1.5,,2.0};  //只初始化前 4 个元素，剩余的元素都会被初始化为 0.0
    
```

(2) 常见成员函数

![image](https://user-images.githubusercontent.com/42632290/177032011-4e8646ef-b25f-46c5-9cf7-ee4277a0b6c9.png)

    另外，在 <array> 头文件中还重载了 get() 全局函数，该重载函数的功能是访问容器中指定的元素，并返回该元素的引用。

    **正是由于 array 容器中包含了 at() 这样的成员函数，使得操作元素时比普通数组更安全**



(3) 迭代器使用详解

1. 遍历

```
#include <iostream>
#include <array>
using namespace std;

int main()
{
    std::array<int, 4> values{};  //初始化 values 容器为 {0,1,2,3}
    
    for (int i = 0; i < values.size(); i++) {
        values.at(i) = i;  //使用at赋值
    }
    
    cout << get<3>(values) << endl;  //使用 get() 重载函数输出指定位置元素
    
    if (!values.empty()) {   //如果容器不为空，则输出容器中所有的元素
        for (auto val = values.begin(); val < values.end(); val++) 
        {
            cout << *val << " ";
        }
    }
}

输出：
    3
    0 1 2 3

```       

2. 增

```
             
```       

3. 删

```
             
```         
             
 4. 改

```
             
```              
  
 5. 查

```
             
```  


##### 2. vector容器

(0) 概述
             
(1) 创建

(2) 常见成员函数
             
(3) 迭代器使用详解

1. 遍历

```
             
```       

2. 增

```
             
```       

3. 删

```
             
```         
             
 4. 改

```
             
```              
  
 5. 查

```
             
```  

##### 3. deque容器

(0) 概述
             
(1) 创建

(2) 常见成员函数
             
(3) 迭代器使用详解

1. 遍历

```
             
```       

2. 增

```
             
```       

3. 删

```
             
```         
             
 4. 改

```
             
```              
  
 5. 查

```
             
```  

##### 4. list容器

(0) 概述
             
(1) 创建

(2) 常见成员函数
             
(3) 迭代器使用详解

1. 遍历

```
             
```       

2. 增

```
             
```       

3. 删

```
             
```         
             
 4. 改

```
             
```              
  
 5. 查

```
             
```  

##### 5. forward_list容器

(0) 概述
             
(1) 创建

(2) 常见成员函数
             
(3) 迭代器使用详解

1. 遍历

```
             
```       

2. 增

```
             
```       

3. 删

```
             
```         
             
 4. 改

```
             
```              
  
 5. 查

```
             
```  
